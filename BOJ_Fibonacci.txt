피보나치 (10870, 2747, 2748)

10870

그냥 재귀를 사용할 수 있는지 묻는 문제였다.

2747

DP 를 이용하지 않으면 시간 초과로 틀리게 된다. ( O(n^2) 인 기존의 재귀 문제를 DP 로 O(n) 을 만들어야 했다. )

2748

그냥 생각없이 배열 크기를 91로 만들었는데 틀렸다고 나왔다. 넣어보기 전에 몇번 확인해볼걸 그랬다.
int 정수형 최대치를 초과해서 BOF 때문에 음수가 나온다.

vector 에서 수를 역순으로 저장하도록 해봤다. 예를 들어 123456789 라는 수가 있으면 vector 에는 987654321 순으로 저장되어 index 0에서 9를 나타내도록 했다. 그래야 계산하기 편했다.

다 구현했는데 돌아가긴한다.
근데 값이 이상하다.
n=3 까지 잘 나오다가 n=4 에서 2+2로 4가 나온다.

이유 찾아보니까 함수를 시작할 때 temp vector 에 res vector 를 복사했었는데
이전에 temp 를 bef 에 인자로 넘겨준 걸 수정해서 bef 까지 바뀌는 거였다.

n=7 일때, 13이 아닌 8이 나와서 보니까 윗자리로 올리는 부분이 잘못돼있었다.
10 이상일 때 또 bef 를 더하고 올리게 처리해놔서 8이 나왔었다.

2자리 수 보니까 vector 범위 넘는 부분 접근할 때 자동으로 0 붙여주는 줄 알고

if(res.size()!=bef.size()) bef.push_back(0);

이 구문 주석 처리해봤는데 안 됐다.

테스트 해봤는데 쓰레기 값이 들어간다. vector<int> test(7,10) 으로 테스트 해봤는데 8,9,11 에는 0, 10 에서는 1041이 값으로 들어간다.

아무튼 풀어서 기분 좋당 히힣!

앗.. 다른 사람들 풀이를 보니까 long long 으로 풀면 되는 걸 이렇게 풀고 있었다.,
자료형이라도 찾아볼 걸 ㅋㅋ

2749

2748 문제에서 뒤에 6자리만 출력하게 했는데 시간 초과 나와서 뒤의 6자리만 계산하게 했는데 메모리 초과 나온다. 참고로 cur 와 5를 비교하는 이유는 1,000,000 로 나눈 나머지는 6자리이고 0부터 연산하기에 0~5까지 6자리 연산이 가능하다.

