1. k 의 개수가 r 개이면 1은 최대 r*2 번 들어갈 수 있다.
ex) k=4 일 때, 11011011011 로 1은 총 8번 들어감.

2. 1은 0개, 11 은 1개, 111은 2개, 1111은 3개, 11111은 4개이다.
이를 0으로 끊어서 생각하면 n=5 일 때 k=2 인 경우는 11을 2번 선택하는 경우, 111을 1번 선택하는 경우로 생각할 수 있다. 11의 경우 n=5 이니 11011 을 하면 조건에 맞는다. 111의 경우 11100, 01110, 00111 이 있다. 이 때, 1이 하나만 있는 경우 0으로 계산하므로 11100, 00111 은 11101, 10111 로도 생각할 수 있다. 따라서 총 6 개이다.

3. 완전 탐색으로 생각해보면 n=5 인 경우 00000 부터 11111 까지 k 를 계산해야한다.
이렇게 될 경우 시간 복잡도는 O(2^n) 이므로 , 최악의 경우 시간복잡도는 2^100 으로 시간 초과가 나오게 된다.

따라서 2번의 경우로 풀어보려고 한다.

-------------------------------------------------- 

cache 를 어떻게 설정할 지 몰라서 풀이를 봤다.

* 보통 점화식을 찾으려고 했다.

풀이에서의 관점은 마지막 비트가 0인지 1인지에 따라 다르게 본 것이였다.

cache[n][k][0 or 1] 형태로 설정한 풀이를 봤는데 n 은 길이, k 는 인접한 비트 수, 0 or 1 은 마지막 비트를 가리키며 이는 수열의 수를 나타낸다.

따라서 점화식을 세우면 다음과 같다.

cache[n][k][0] = cache[n-1][k][0] + cache[n-1][k][1]
cache[n][k][1] = cache[n-1][k-1][1] + cache[n-1][k][0]

뒤에 0이 붙는 경우 인접비트는 늘어나지 않으니 이를 제외했을 때 인접비트가 k 개여야 하고,
뒤에 1이 붙는 경우 이를 제외했을 때 맨 뒤가 1이면 인접 비트가 1 늘어나니 cache[n-1][k-1][1] 을 더해주는 것이고, 맨 뒤가 0이면 1을 붙여도 인접 비트가 늘어나지 않으니 cache[n-1][k][0] 을 더해주는 것이다.

해당 예제 소스를 보니 cache 의 선언을 int cache[101][100][2] 가 아닌 int[][][] cache = new int[101][100][2] 와 같이 선언을 해서 일반 선언과 new 의 차이점을 알아봤다.

동적할당을 받지 않고 객체를 생성할 경우 객체는 Stack 영역에 올라가고 범위를 벗어날 경우 메모리가 자동적으로 해제되는데 동적할당을 할 경우 Heap 영역에 할당을 받아 delete 를 이용하여 직접 해제해주기 전까지 메모리에 유지된다고 한다. 따라서 함수에서 잠깐 쓰고 자동으로 해제할 것이 아닌 지속적으로 사용하기 위해서는 Heap 메모리를 이용해야한다고 한다. 앞으로 DP 할 때 new 선언자를 애용하자. 또한 new 선언은 생성자를 호출하여 초기화한다.

cache[1][0][0] = 1;
cache[1][0][0] = 1;

위와 같이 따로 값을 넣어준 이유는 n이 1일 경우 cache[0][.][.] 에 접근하기 때문이다.

배열의 3번째 인덱스에 들어가는 값은 n번째 부분에서의 값이 0이냐 1이냐를 나타내는 것이다.
따라서 n 에서의 수열의 개수를 구하려면 cache[n][k][0]+cache[n][k][1] 을 해야한다.

어차피 처음에 초기화 하고 다 계산하니까 new 선언 안해도 될 것 같다. int [][][] new 형태로 선언하니 에러난다.

다른 부분은 다 되는데 예제의 마지막 부분인 100 90 을 하면 계속 쓰레기값이 나온다.

뭐지 최댓값에서만 쓰레기값 나오길래 배열 크기 +1 해서 돌렸는데 똑같았다.
설마 IDE 문제인가 싶어서 그냥 올려봤더니 맞았다고 나온다.

거의 풀이를 보다시피 하며 풀었지만 이렇게 조금씩 노력하다보면 언젠가 안 보고도 풀 날이 오지 않을까?

memset 을 활용해서 재귀로도 푼 코드를 봤다.

문재해결전략세트에 나올만한 깔끔한 풀이인 것 같다.
