0 000
1 001
2 010
3 011
4 100
5 101
6 110
7 111

101 0110 0101

102 0110 0110
103 0110 0111
104 0110 1000

105 0110 1001

71 0100 0111

그럼 n 만큼 반복문을 돌려서 각 원소별로 low ~ high 중 비트 차이가 최소인 것으로 vector 에 push 해주면 수열 나올 것 같다. 비트 차이나는 개수가 같은 경우 사전순으로 먼저오는 것을 출력하니 하나 찾고 넘어가면 맨 앞에 있는 원소가 조건을 만족하는 제일 작은 수이므로 자연스럽게 사전순이 된다.

각 비트 차이를 계산하는 방법은 둘 다 2로 나눴을 때 나머지가 다른 경우를 세면 되며 0을 2로 나누면 나머지는 2이므로 길이가 짧은 이진수의 왼쪽을 0으로 채울 필요도 없다.

따라서 n low high 를 입력받은 뒤 n 만큼 반복문을 돌리고 vec_a 을 입력받는다. 그 뒤 n 만큼 반복문을 돌려서 각 원소별로 최소가 되는 B 를 찾아 push 해준다.

34 행의 while 조건문 내부에 tem_j/=2 를 했더니 lvalue required as left operand of assignment 에러가 나온다.찾아보니까 tem_j 가 변해야 되는데 변수가 아니라 상수라 그렇다고 한다.
tem_j 는 변수인데 왜 이러는 지 모르겠다. 그냥 반복문 내부에 tem_j/=2 를 넣어주니 에러 없이 컴파일 되기는 했다. 돌려보니까 결과가 출력이 안 되고 계속 돌기만 한다.

쉬운 것부터 차근 차근하려고 정답 비율 제일 높은 걸로 푸는데 알고보니 푼 사람이 6명인 문제였다.

시간 초과가 나온다.

n 은 50이고 각 원소는 2^31 까지 가능하니 최악의 경우 n=50 일 때, low=0, high=2^31 로 시간 초과가 나올 수 밖에 없었던 것 같다.

만약 A 의 원소가 low 와 high 사이의 값이라면 그 값을 vec_b 로 넣어주기로 했다.

do while 문을 수정해야 괜찮아질 것 같다.

하나 하나 2로 나눠가며 수를 세는 것보다 A 와 B 를 비교한다고 할 때 !A & B 를 해서 살아있는 비트의 수를 구하는 게 더 빠를 것 같다. 

켜진 비트 개수 구하는 방법 쉽게 구현할 수 없다가 코드 하나를 발견했다.
v&v-1 을 반복하는 횟수가 켜진 비트의 수였는데, -1을 빼줄 때마다 마지막 1비트가 0으로 되고 그 아래는 1로 채워지니 and 연산을 하면 0이 된 1비트 앞의 1비트까지만 남는다. 이런 식으로 세는 것 같다.

vec_b 에 계속 넣었다가 빼주는 것보다 차이가 가장 적을 때 value 를 기억해두고 있다가 마지막에 넣어주는 게 더 효율적이다.

바꾼 코드로 실행해보니 결과는 바로 바로 나오지만 이상한 결과값이 나온다.

계산 과정을 생각해보자.

!71 1011 1000

&

101 0110 0101   0010 0000

102 0110 0110   0010 0000
103 0110 0111   0010 0000
104 0110 1000   0010 1000

105 0110 1001   0010 1000

and 연산을 하면 A 의 원소에 대해 not 연산을 했을때 0으로 바뀌는 것에 대해 다른 부분을 같은 부분으로 인식한다. 따라서 같으면 1이 나오도록 !xor 연산을 해줘야 한다.

!xor 연산을 해줘도 그대로 나오길래 왜 그럴까 생각해봤는데 비트연산에서 not 연산자로 ! 써서 그렇다. 확인해보니 ! 를 할 경우 0이 된다.

악 잘 되는데 시간 초과 뜬다 ㅠㅡㅠㅡㅠㅡㅠ

그래도 엄청난 발전인 듯! 배움을 머리에만 쌓아놓는 게 아닌 응용했다!

자 그럼 시간을 체크해보자.

n=50 이어도 A의 원소들이 low~high 에 포함되어 있다면 vec_b 에 push_back 만 하므로 push_back 의 시간복잡도가 O(1) 이니 시간복잡도는 O(1) 이다. 

만약 이 범위내에 없다면 n=50 일 경우, 그리고 범위가 넓을 경우 50 * (2^31 - 50)^2 에 달하는 계산을 해야한다. 어떻게 줄일 수 있을까?

꼭 전체 범위를 확인해야 될까? A 의 원소에 대해 비트를 꺼진 위치에 하나씩 추가해가며 확인하는 방법 어떨까?

~(~vec_a[i]^j) 은 다른 부분의 비트만 켜져있다. 그렇다면 이 변수를 가지고 이 부분만 추가해주는 반복문을 만들 수 있지 않을까? 그러면 반복문의 도는 횟수가 high-low+1 이 아닌 32번이 될 것이다. 문제는 1을 차근차근 추가시켜야 되는데 어떤 방식으로 추가시켜야되는가 이다.
-> 그렇다면 j 를 넣어줘야되는데 그럼 또 low~high 까지 반복문을 돌려야 한다. low, high 기준으로 생각하는 게 아닌 더 적은 시행 횟수를 지닌 n 을 기준으로 생각해야한다.

그렇다면 비트연산자를 사용하는 만큼 vector 가 아닌 bit 연산에 적합한 STL 을 사용하는 게 더 적절하지 않을까? 그래서 bitset 이라는 STL 을 찾아보게 되는데 여기에 쓰기 적절한 것 같다.

그냥 vec_a 의 원소 하나를 가져와서 만약 0100 0111 라면 작은 수가 앞에 오도록 최하위 비트부터 반전시켜보며 차이 개수가 가장 적은 것을 찾는다. 음.. 안 될 것 같다. 그럼 하나 다를때가 아닌 여러개 다를 경우 계속 for 문으로 들어가주며 반전할 위치를 찾아야되는 데 그럼 n 하나당 32! 번 연산하게 된다.

그렇다면 다음으로 생각해볼 수 있는건 low 부터 high 까지가 연속적인 수라는 것이다.
그렇다면 앞의 비트에서 가장 차이가 적게 나도록 하고 거기부터 살펴보면 되지 않을까?
0100 0111 의 경우 low~high 에서 같을수는 없기에 1개가 다른 경우를 살펴보면 0110 이라는 것이다.

반을 나눠서 생각하면 되지 않을까? 전체 크기를 32bit 로 하고 앞의 16비트 확인해서 일치하면 뒤에서 나누고 .. 음 이러면 그냥 다 하는거랑 똑같잖아.

101 0110 0101

102 0110 0110
103 0110 0111
104 0110 1000

105 0110 1001
