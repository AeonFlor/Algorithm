11728번 배열 합치기

오름차순으로 정렬되어있는 두 배열을 합쳐 정렬하라는 문제이다.

일단 기능이 돌아가게 구현하자는 생각으로 해봤는데 입력되는 두 배열은 이미 정렬되어 있으므로 각 배열 맨 앞의 두 수 즉, 각 배열의 제일 작은 수를 비교해봐서 작은 거부터 출력하고 지우는 방식으로 구현하고자 했다.

C++ STL 에서 많이 본 게 Vector 여서 일단 vector 로 구현해봤는데 하다보니 queue 가 더 편한 것 같아서 queue 로 바꿔서 구현했다. STL 도 문제 상황별로 잘 써야겠다.


처음에는 33행 조건에 a_seq.front()<b_seq.front() 만 적어놨는데 계속 segmentation fault 에러나길래 뭐가 잘못된거지 싶었다. 

생각해보니까 한 배열이 다른 배열보다 짧으면 한 배열이 끝났을 때 다른 배열이 비교할 대상이 없어서 나는 에러였던 것 같다. 

그래서 a_seq.empty() 가 True 이면 b_seq.pop() 하도록 구현했고 아래는 남은 배열안의 값들을 다 출력하는 코드다.

33행의 조건문 고칠 때 a_seq.front()<b_seq.front() || b_seq.empty() && !(a_seq.empty()) 로 고쳤더니 연산자 우선 순위 이상하게돼서 이것도 안 됐다. 이런 기본적인 부분에서 아무 생각없이 실수하다니.. 실제로 직접 코딩하게 되면 어려울거라고 생각했는데 상상 이하라 슬프다. 더 노력해야겠다. 이거 구현하는데 1시간 20분 걸렸다. 성장하자 성장!

아무튼 제대로 동작하는 걸 확인하고 나서 기뻐하며 백준에 올렸더니 시간초과가 뜬다..

시간 복잡도 계산하면 입력 제외하고 2n+m-n (n: 짧은 배열 길이, m: 긴 배열 길이) 아닌가?
그럼 O(n) 인데 조금 더 효율적인 알고리즘이 있나보다.

다른 블로그 참조해서 코드 작성했는데 어디가 틀린건지 모르겠다. ( https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html ) 왜 자꾸 segmenatation fault 뜨는거지? 보니까 main 에서 seq 범위에 맞지 않게 들어가서 뜨는 줄 알고 초기화 해놓고 인덱스로 접근하는 방식으로 해봤는데 계속 뜬다. 나중에 알아보고 일단 다른 방법으로 해봐야겠다.

애초에 쉬운 문제를 어렵게 풀고 있는 것 같다.

다시 풀었는데 또 시간 초과다.
머리 아프다. 오늘은 GG.
